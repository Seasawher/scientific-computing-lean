<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Differentiation</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">Scientific Computing in Lean</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/sorry-friendly-programming.html"><strong aria-hidden="true">1.1.</strong> Sorry Friendly Programming</a></li></ol></li><li class="chapter-item expanded "><a href="working-with-arrays.html"><strong aria-hidden="true">2.</strong> Working with Arrays</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="working-with-arrays/basics.html"><strong aria-hidden="true">2.1.</strong> Basic Operations</a></li><li class="chapter-item expanded "><a href="working-with-arrays/tensor-operations.html"><strong aria-hidden="true">2.2.</strong> Tensor Operations</a></li><li class="chapter-item expanded "><a href="working-with-arrays/abstract-interface.html"><strong aria-hidden="true">2.3.</strong> Abstract Array Interface</a></li><li class="chapter-item expanded "><a href="working-with-arrays/optimizing-arrays.html"><strong aria-hidden="true">2.4.</strong> Optimizing Array Expressions</a></li></ol></li><li class="chapter-item expanded "><a href="differentiation.html" class="active"><strong aria-hidden="true">3.</strong> Differentiation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="differentiation/zoo.html"><strong aria-hidden="true">3.1.</strong> Zoo of Differentiation Operators</a></li><li class="chapter-item expanded "><a href="differentiation/new-functions.html"><strong aria-hidden="true">3.2.</strong> Defining New Functions</a></li><li class="chapter-item expanded "><a href="differentiation/theoretical-aspects.html"><strong aria-hidden="true">3.3.</strong> Theoretical Aspects*</a></li></ol></li><li class="chapter-item expanded "><a href="function-transformations.html"><strong aria-hidden="true">4.</strong> Function Transformations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="function-transformations/new-transformation.html"><strong aria-hidden="true">4.1.</strong> Defining New Function Transformation</a></li><li class="chapter-item expanded "><a href="function-transformations/algorithm.html"><strong aria-hidden="true">4.2.</strong> Function Transformation Algorithm*</a></li></ol></li><li class="chapter-item expanded "><a href="problem-transformations.html"><strong aria-hidden="true">5.</strong> Problem Transformations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="problem-transformations/solve-function.html"><strong aria-hidden="true">5.1.</strong> Solve Function</a></li><li class="chapter-item expanded "><a href="problem-transformations/approximation.html"><strong aria-hidden="true">5.2.</strong> Approximation</a></li></ol></li><li class="chapter-item expanded "><a href="differential-equations.html"><strong aria-hidden="true">6.</strong> Differential Equations</a></li><li class="chapter-item expanded "><a href="probabilistic-programming.html"><strong aria-hidden="true">7.</strong> Probabilistic Programming</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="differentiation"><a class="header" href="#differentiation">Differentiation</a></h1>
<p><em>automatic and symbolic differentiation is a key building block for scientific computing software</em></p>
<p>The backbone of any numerical/scientific/machine learning software is
an automatic and/or symbolic differentiation. In SciLean, automatic and
symbolic differentiation is build on top of these two operators:</p>
<ol>
<li>
<p>Differential <code>∂ : (X → Y) → (X → X → Y)</code></p>
</li>
<li>
<p>Adjoint <code>†: (X → Y) → (Y → X)</code></p>
</li>
</ol>
<p>The differential <code>∂</code> tells us how much does the function <code>f : X → Y</code>
changes in the direction <code>dx : X</code> at the point <code>x : X</code>. The usual
mathematical definition is:</p>
<p>(
\partial \texttt{f x dx} := \lim_{h \rightarrow 0} \frac{f(x + dx) - f(x)}{h}
)</p>
<p><code>$$ \frac{1}{3} $$</code></p>
<p>Because mathlib is not yet ported to Lean 4 this definition is not used
in SciLean. Right now, the differential <code>∂</code> is just postulated to exist.</p>
<p>The adjoint <code>†</code> is just well known matrix transposition. Thus for real
valued matrix <code>A</code></p>
<p>.. math:: (A^\dagger)<em>{ij} = A</em>{ji}</p>
<p>..</p>
<p>For a general linear map <code>A : X → Y</code> between two Hilbert spaces <code>X</code> and <code>Y</code>,
the adjoint is defined via</p>
<p>.. math :: \langle A x, y \rangle = \langle x, A^\dagger y \rangle  \qquad , \forall x \in X, ,y \in Y</p>
<p>-/</p>
<p>/-!</p>
<p>We will show that these two operators give a rise to a whole zoo of operators</p>
<ol>
<li>
<p>Differential <code>∂ : (X → Y) → (X → X → Y)</code></p>
</li>
<li>
<p>Adjoint <code>†: (X → Y) → (Y → X)</code></p>
</li>
<li>
<p>Adjoint Differential <code>∂† : (X → Y) → (X → Y → X)</code></p>
</li>
<li>
<p>Derivative <code>ⅆ : (ℝ → X) → (ℝ → X)</code></p>
</li>
<li>
<p>Gradient <code>∇ : (X → ℝ) → (X → X)</code></p>
</li>
<li>
<p>Divergence <code>∇· : (X → X) → (X → ℝ)</code></p>
</li>
<li>
<p>Forward Mode AD <code>fwdDiff : (X → Y) → (X → X×(X → Y))</code></p>
</li>
<li>
<p>Reverse Mode AD <code>revDiff : (X → Y) → (X → X×(Y → X))</code></p>
</li>
<li>
<p>Dual Number AD <code>dualDiff : (X → Y) → (X×X → Y×Y)</code></p>
</li>
</ol>
<p>-/</p>
<p>/-!</p>
<h1 id="differential"><a class="header" href="#differential">Differential</a></h1>
<p>-/</p>
<p>section Differential</p>
<p>/-!</p>
<p>The simples possible example: What is the differential of identity function?</p>
<p>-/</p>
<p>#check (∂ λ x : ℝ =&gt; x)
rewrite_by (simp; trace_state /- .unfold -/ )</p>
<p>/-!</p>
<p>As expected the change of identity function is just <code>dx</code> and it does not depend
on the position <code>x</code>.</p>
<p>(Note: The SciLean's custom notation <code>x:term rewrite_by t:convSeq</code>
applies tactic <code>t</code> on the term <code>x</code>. This notation confuses the <code>#check</code>
command. To see the actual result it is better to use the <code>trace_state</code>
tactic. TODO: Add a document explaining the technical detail of <code>rewrite_by</code>
notation. TODO: Add delaborator for terms created with <code>AutoImpl</code>)</p>
<p>Another way to check that the differential is computed correctly</p>
<p>-/</p>
<p>example : (∂ λ x : ℝ =&gt; x) = (λ x dx =&gt; dx) := by simp</p>
<p>/-!</p>
<p>This has the disadvantages that we need to know the result beforehand.</p>
<p>Few more basic derivatives: of a constant, quadratic function, sine</p>
<p>-/</p>
<p>#check (∂ λ x : ℝ =&gt; (1 : ℝ))
rewrite_by
(simp; trace_state) /- .unfold -/</p>
<p>#check (∂ λ x : ℝ =&gt; x * x)
rewrite_by
(simp; trace_state) /- .unfold -/</p>
<p>#check (∂ λ x : ℝ =&gt; Math.sin x)
rewrite_by
(simp; trace_state) /- .unfold -/</p>
<p>/-!</p>
<p>The result <code>fun x dx =&gt; dx * x + x * dx</code> is slightly undesirable. We
would like to get <code>fun x dx =&gt; 2 * dx * x</code>. Such algebraic manipulation
is within the scope of mathlib's tactics so we will wait for mathlib
port to Lean 4.</p>
<p>-/</p>
<p>/-!</p>
<p>Let's introduce few generic functions  to demonstrate some general differentiation
results</p>
<p>-/
variable {X Y Z : Type} [Vec X] [Vec Y] [Vec Z]
variable (f : Y → Z) [IsSmooth f]
variable (g : X → Y) [IsSmooth g]</p>
<p>/-!</p>
<p>The most crucial tool when computing derivatives is the chain rule, as a proof</p>
<p>-/</p>
<p>example : (∂ λ x =&gt; f (g x)) = (λ x dx =&gt; ∂ f (g x) (∂ g x dx)) :=
by simp</p>
<p>/-!</p>
<p>Or as a symbolic computation</p>
<p>-/</p>
<p>#check (∂ λ x =&gt; f (g x))
rewrite_by
(simp; trace_state) /- .unfold -/</p>
<p>/-!</p>
<p>Another common rule is the product rule</p>
<p>-/</p>
<p>variable (ϕ ψ : ℝ → ℝ) [IsSmooth ϕ] [IsSmooth ψ]</p>
<p>#check (∂ λ x =&gt; ϕ x * ψ x)
rewrite_by
(simp; trace_state) /- .unfold -/</p>
<p>/-!</p>
<h2 id="derivative"><a class="header" href="#derivative">Derivative</a></h2>
<p>The standard notion of derivative takes a function from reals to reals, <code>f : ℝ → ℝ</code>,
and produces again a function from, usually denoted with <code>f' : ℝ → ℝ</code>.</p>
<p>The differential <code>∂</code> does not fit this. The well know result that
derivative of exponential is exponential <code>exp' = exp</code> can't be expressed as
easily with differential.</p>
<p>The naive statement does not even typecheck</p>
<p>-/</p>
<p>#check_failure ∂ Math.exp = Math.exp</p>
<p>/-!</p>
<p>The <code>exp' = exp</code> is this slightly cumbersome statement</p>
<p>-/</p>
<p>example : (λ t =&gt; ∂ Math.exp t 1) = Math.exp := by simp</p>
<p>/-!</p>
<p>For this reason we introduce a new operator, derivative <code>ⅆ : (ℝ → X) → (ℝ → X)</code>.
Which is defines as follows</p>
<p>-/</p>
<p>example (f : ℝ → X) : ⅆ f = λ t =&gt; ∂ f t 1 :=
by simp</p>
<p>/-!</p>
<p>Now we have</p>
<p>-/</p>
<p>example : ⅆ Math.exp = Math.exp := by simp</p>
<p>/-!</p>
<p>(TODO: Right now simplifier needs to unfold <code>derivative</code>. Fix it!)</p>
<p>We provide convenient notation, <code>ⅆ t, f t</code> and <code>ⅆ (t:=t₀), f t</code>, for
taking derivative with a respect to an explicit variable.</p>
<p>-/
section DerivativeNotation</p>
<pre><code>variable (f : ℝ → X) (t₀ : ℝ)

-- effectively translates `t,` to `λ t =&gt;`
example : (ⅆ t, f t) = ⅆ (λ t =&gt; f t ) := by rfl

-- similar as above but also applies `t₀`
example : (ⅆ (t:=t₀), f t) = ⅆ (λ t =&gt; f t) t₀ := by rfl
</code></pre>
<p>end DerivativeNotation</p>
<p>/-!</p>
<p>..</p>
<p>The notation <code>ⅆ (t:=t₀), f t</code> tries to mimick the mathematical notation</p>
<p>.. math:: \frac{d}{dt}\bigg\rvert_{t=t_0} f(t)</p>
<p>-/</p>
<p>/-!</p>
<h2 id="debugging-differentiation"><a class="header" href="#debugging-differentiation">Debugging Differentiation</a></h2>
<p>Sometimes the differentiation is not doing what we expect. It is crucial
to know how to figure out what went wrong.</p>
<p>To demonstrate this, let's introduce a function <code>h</code> but without the smoothness
proof i.e. we do not introduce <code>[IsSmooth h]</code></p>
<p>-/</p>
<p>variable (h : X → Y)</p>
<p>/-!</p>
<p>Now the chain rule for <code>f</code> and <code>h</code> fails</p>
<p>-/</p>
<p>example : (∂ λ x =&gt; f (h x)) = (λ x dx =&gt; ∂ f (h x) (∂ h x dx)) :=
by simp   -- no progress
admit  -- we have to give up</p>
<p>/-!</p>
<p>We have to use the <code>admit</code> tactic to close the goal as <code>simp</code> is unable
to do it right now.</p>
<p>The problem is that <code>simp</code> can't apply chain rule because it is missing
the proof of smoothness of <code>h</code>. To figure this out, we turn on the option
<code>trace.Meta.Tactic.simp.discharge</code></p>
<p>-/</p>
<p>set_option trace.Meta.Tactic.simp.discharge true in
example : (∂ λ x =&gt; f (h x)) = (λ x dx =&gt; ∂ f (h x) (∂ h x dx)) :=
by simp; admit</p>
<p>/-!</p>
<p>If you click on <code>simp</code>, one of the messages will be</p>
<p>::</p>
<p>[Meta.Tactic.simp.discharge] SciLean.diff_of_comp, failed to synthesize instance
SciLean.IsSmooth fun x =&gt; h x</p>
<p>(TODO: currently there is tons of crap that should not be there)</p>
<p>If we provide the smoothness proof we can observe all rewrites by turning on
<code>trace.Meta.Tactic.simp.rewrite</code></p>
<p>-/</p>
<p>variable [IsSmooth h]</p>
<p>set_option trace.Meta.Tactic.simp.rewrite true in
example : (∂ λ x =&gt; f (h x)) = (λ x dx =&gt; ∂ f (h x) (∂ h x dx)) :=
by simp</p>
<p>/-!</p>
<p>Now <code>simp</code> shows the application of the chain rule</p>
<p>::</p>
<p>[Meta.Tactic.simp.rewrite] SciLean.diff_of_comp:99, ∂fun x =&gt;
f (h x) ==&gt; fun x dx =&gt; SciLean.differential f (h x) (SciLean.differential (fun x =&gt; h x) x dx)</p>
<p>A bit more complicated computation</p>
<p>-/</p>
<p>set_option trace.Meta.Tactic.simp.rewrite true in
#check (∂ λ x : ℝ =&gt; x * Math.exp (x*x) + x)
rewrite_by
(simp; trace_state) /- .unfold -/</p>
<p>/-!</p>
<p>Clicking on <code>simp</code> reveals fairly long list of rewrites.</p>
<p>-/</p>
<p>end Differential</p>
<p>/-!</p>
<h1 id="defining-differentiable-function"><a class="header" href="#defining-differentiable-function">Defining Differentiable Function</a></h1>
<p>Sometimes we want to define our own differentiable functions</p>
<p>-/</p>
<p>def square (x : ℝ) := x * x</p>
<p>/-!</p>
<p>We might be surprized that differentiating this function does not work</p>
<p>-/</p>
<p>example : (∂ square) = (λ x dx =&gt; dx * x + x * dx) :=
by
simp  -- this does nothing as we know nothing about <code>square</code>
unfold square  -- unfold definition of <code>square</code>
simp  -- now it works</p>
<p>/-!</p>
<p>Manually unfolding every definition can get tedious. To circumvent that,
we can annotate the definition of <code>square</code> to indicate that it is
differentiable.</p>
<p>-/</p>
<p>def square_v1 (x : ℝ) : ℝ := x * x
argument x
isSmooth, diff</p>
<p>/-!</p>
<p>(TODO: When using <code>def</code> with annotations, we <strong>have to</strong> explicitly specify
the return type. Remove this limitation or add a warning when the
return type is missing.)</p>
<p>The <code>argument x</code> specifies that everything that follows concerns the
argument <code>x</code>. The <code>isSmooth</code> generates proof that <code>square_v1</code> is
smooth in the argument <code>x</code> and <code>diff</code> defines a new function
<code>square_v1.arg_x.diff</code> that is the function's differential.</p>
<p>There are few variants that are useful when full automation fails or
produces undesirable results.</p>
<p>-/</p>
<p>def square_v2 (x : ℝ) : ℝ := x * x
argument x
-- specify how to prove smoothness
isSmooth := by unfold square_v2; infer_instance,
-- specify what the differential is and how to prove it
diff := 2 * dx * x by simp[diff, square_v2]; funext x dx; ring</p>
<p>def square_v3 (x : ℝ) : ℝ := x * x
argument x
-- proof is done automatically
isSmooth,
-- specify how to compute differential
diff by simp[square_v3]</p>
<p>/-!</p>
<p>Defining a new function, <code>square_v1.arg_x.diff</code> for the differential
can be undesirable. Sometimes we want <code>∂ square</code> to directly simplify
to <code>λ x dx =&gt; dx * x + x * dx</code>. To achieve this, we use <code>diff_simp</code>
instead of <code>diff</code>.</p>
<p>-/</p>
<p>def square_v4 (x : ℝ) : ℝ := x * x
argument x
isSmooth,
diff_simp by simp[square_v4]</p>
<p>/-!</p>
<p>The <code>diff_simp</code> annotation allows the same variants as <code>diff</code>.</p>
<p>Proof that the second derivative is <code>2</code>. We have to do manual unfolding
when working with <code>square_v3</code> but with <code>square_v4</code> the proof is immediate</p>
<p>-/</p>
<p>example : (λ x =&gt; ∂ ∂ square_v2 x 1 1) = (λ x =&gt; 2) :=
by
simp  -- simp gets stopped on <code>square_v3.arg_x.diff</code>
unfold square_v2.arg_x.diff -- manually unfold definition
simp  -- we can continue with computation</p>
<p>example : (λ x =&gt; ∂ ∂ square_v4 x 1 1) = (λ x =&gt; 2) :=
by
simp  -- done immediately</p>
<p>/-!</p>
<p>We missed our chance to add annotations to the original function <code>square</code>.
We can add additional annotations later on with <code>function_properties</code>.</p>
<p>-/</p>
<p>function_properties square (x : ℝ) : ℝ
argument x
isSmooth, diff_simp</p>
<p>-- now we can differentiate <code>square</code>
example : ∂ square = λ x dx =&gt; dx * x + x * dx := by simp</p>
<p>/-!</p>
<p>The keyword <code>function_properties</code> works exactly like <code>def</code> with annotations
but you do not provide the function definition <code>:= ...</code>. Argument types
and order have to match exactly the original definition but the argument
names do not have to be the same.</p>
<p>-/</p>
<p>/-!</p>
<h2 id="multiple-arguments"><a class="header" href="#multiple-arguments">Multiple Arguments</a></h2>
<p>(TODO: Explain how annotations work with multiple arguments. The current
behavior is a bit limiting, so I should rewrite how they work before
I write this section.)</p>
<p>-/</p>
<p>/-!</p>
<h2 id="how-do-annotations-work"><a class="header" href="#how-do-annotations-work">How Do Annotations Work?</a></h2>
<p>The <code>isSmooth</code> and <code>diff</code> annotations might appear mysterious but they
are simple macros.</p>
<p>This definition
-/</p>
<p>def cube (x : ℝ) : ℝ := x * x * x
argument x
isSmooth := by unfold cube; infer_instance,
diff := 3 * dx * x * x by simp[diff,cube]; funext x dx; ring</p>
<p>/-!</p>
<p>Is unfolded to (we have to use a new identifier <code>cube_v1</code> as <code>cube</code> is
already defined)</p>
<p>-/</p>
<p>def cube_v1 (x : ℝ) : ℝ := x * x * x</p>
<p>-- proof of smoothness
instance cube_v1.arg_x.isSmooth : IsSmooth (λ x =&gt; cube_v1 x) :=
by unfold cube_v1; infer_instance</p>
<p>-- differential definition
def cube_v1.arg_x.diff (x dx : ℝ) : ℝ := 3 * dx * x * x</p>
<p>-- simplifier rule
@[simp]
theorem cube_v1.arg_x.diff_simp
: ∂ cube_v1 = cube_v1.arg_x.diff :=
by simp[diff,cube_v1]; funext x dx; ring</p>
<p>/-!</p>
<p>Using <code>diff_simp</code> annotation does not define <code>cube_v1.arg_x.diff</code> and
the simp theorem states directly <code>∂ cube_v1 = λ x dx =&gt; 3 * dx * x * x</code>.</p>
<p>-/</p>
<p>/-!</p>
<h1 id="adjoint-differential"><a class="header" href="#adjoint-differential">Adjoint Differential</a></h1>
<p>Finding the minimum of a function <code>f : X → ℝ</code> with gradient descent
requires function's gradient <code>∇ f : X → X</code>.</p>
<p>However, can we compute the gradient just with the differential <code>∂</code>?
No we can't! We need an adjoint <code>†</code> too!</p>
<p>The differential <code>∂ f x</code> at point <code>x</code> is a linear function <code>X → R</code>.
When we take an adjoint and apply one we get an element of <code>X</code>. That
is the gradient of <code>f</code> at <code>x</code>!</p>
<p>In finite dimension, we can think about differential <code>∂ f x</code> is a row vector.
To get a column vector we have to transpose it i.e. take its adjoint.</p>
<p>For general function <code>f : X → Y</code>, we define adjoint differential
<code>∂† : (X → Y) → (X → Y → X)</code> as <code>∂† f x dy := (∂ f x)† dy</code></p>
<p>Taking adjoint makes sense only for functions between Hilbert spaces.
Let's introduce few of those</p>
<p>-/</p>
<p>section AdjointDifferential</p>
<p>variable {X Y Z} [Hilbert X] [Hilbert Y] [Hilbert Z]</p>
<p>/-!</p>
<p>To stress the definition of adjoint differential</p>
<p>-/</p>
<p>example (f : X → Y) : ∂† f = λ x dy =&gt; (∂ f x)† dy := by rfl</p>
<p>/-!</p>
<p>Similarly to derivative <code>ⅆ</code>, we define a specialized operator gradient <code>∇</code>
for real valued functions over any Hilbert space</p>
<p>-/</p>
<p>example (f : X → ℝ) : ∇ f = λ x =&gt; (∂ f x)† 1 := by rfl</p>
<p>/-!</p>
<p>The important result is that the gradient of squared norm <code>∥x∥²</code> is <code>2*x</code></p>
<p>-/</p>
<p>#check (∇ (x : X), ∥x∥²)
rewrite_by
(simp; trace_state)  /- .unfold -/</p>
<p>/-!</p>
<p>(TODO: Make sure we do not need to unfold gradient and hold here`)</p>
<p>Another fun result is that the gradient of <code>⟪A x, x⟫</code> is <code>(A† + A) x</code></p>
<p>-/</p>
<p>variable (A : X → X) [HasAdjDiff A] [IsLin A]</p>
<p>#check (∇ x, ⟪A x, x⟫)
rewrite_by
(simp[adjointDifferential]; trace_state) /- .unfold -/</p>
<p>/-!</p>
<p>(TODO: Ughh, this requires too many assumptions on A and too many unfolding`)</p>
<p>Similar to chain rule for differential, we have a chain rule for the adjoint
differential but the composition is in reverse</p>
<p>-/</p>
<p>variable (f : Y → Z) [HasAdjDiff f]
variable (g : X → Y) [HasAdjDiff g]</p>
<p>example : (∂† λ x =&gt; f (g x)) = (λ x dz =&gt; ∂† g x (∂† f (g x) dz)) :=
by simp</p>
<p>/-!</p>
<p>(TODO: Explain what <code>HasAdjDiff f</code> is)</p>
<p>-/</p>
<p>/-!</p>
<h2 id="euler-lagrange-equations"><a class="header" href="#euler-lagrange-equations">Euler-Lagrange Equations</a></h2>
<p>Let's write down Euler-Lagrange equations to demonstrate SciLean's notation
in a bit complicated scenario.</p>
<p>They are usually written in the following way</p>
<p>.. math:: \frac{d}{dt} \frac{\partial}{\partial \dot x} L(x(t),\dot x(t)) - \frac{\partial}{\partial x} L(x(t),\dot x(t)) = 0</p>
<p>However, the partial derivative notation is really ambiguous. Thus a bit
more explicit form is</p>
<p>.. math:: \frac{d}{ds}\bigg\rvert_{s=t} \frac{\partial}{\partial v}\bigg\rvert_{v=\dot y(s)} L(y(s),v) - \frac{\partial}{\partial x}\bigg\rvert_{x=y(t)} L(x, \dot y(t)) = 0</p>
<p>And this form can be written in SciLean relatively nicely.</p>
<p>-/</p>
<p>variable (L : X → X → ℝ)  -- Lagrangian
variable (y : ℝ → X)      -- trajectory
variable (t : ℝ)          -- time</p>
<p>#check
ⅆ (s:=t), ∇ (v:=ⅆ y s), L (y s) v - ∇ (x:=y t), L x (ⅆ y t) = 0</p>
<p>/-!</p>
<p>Let's plug in a Lagrangian for a particle in a potential field and hopefully
we get the correct equations of motion.</p>
<p>-/
def L' (ϕ : X → ℝ) (m : ℝ) (x v : X) := 1/2<em>m</em>∥v∥² - ϕ x</p>
<p>variable [IsSmooth y]  -- trajectory is smooth
variable (ϕ : X → ℝ)  [HasAdjDiff ϕ]
variable (m : ℝ) -- mass</p>
<p>#check
(ⅆ (s:=t), ∇ (v:=ⅆ y s), L' ϕ m (y s) v
-
∇ (x:=y t), L' ϕ m x (ⅆ y t))
rewrite_by
(-- Currently broken :(
-- simp
-- simp[gradient,hold]
-- simp[derivative]
trace_state) /- .unfold -/</p>
<p>/-!</p>
<p>(TODO: Make sure we get these rewrite to make the result look nicer</p>
<p><code>2 * (1/2) = 1</code></p>
<p><code>differential (∂y) t 1 1 = ⅆ (ⅆ y) t</code></p>
<p><code>adjointDifferential (fun x =&gt; ϕ x) (y t) (-1) = - ∇ ϕ (y t)</code>)</p>
<p>The result is (with the TODO rewrites) <code>m * ⅆ (ⅆ y) t + ∇ ϕ (y t)</code> which
exactly corresponds to the equation of a particle in a potential field <code>ϕ</code></p>
<p>.. math:: m \ddot y(t) = - \nabla \phi (y(t))</p>
<p>-/</p>
<p>end AdjointDifferential</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="working-with-arrays/optimizing-arrays.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="differentiation/zoo.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="working-with-arrays/optimizing-arrays.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="differentiation/zoo.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
